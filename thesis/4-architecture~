\chapter{Architecture design}
\label{cha:architecture}

This chapter describes the requirements for a business-games-architecture and shows how a Business Game Engine (BGE) and a Business Game Description (BGD) mechanism can be designed in order to meet these requirements.

\section{Software requirements}
\label{sec:requirements}

\subsection{Description mechanism}
\label{subsec:req:description}

In order to enable game writers to write their own round-based business games a programming language or game-description mechanism is needed which covers all aspects of round-based games as described in section \ref{sec:round}:
\begin{itemize}
\item The game writer must be able to define \textbf{input variables} as well as the input domain. The latter is needed for the validation of user input. Furthermore, he must be able to decide if the players are asked for a variable or predefined input (empty textfield vs. checkbox).
\item \textbf{Parameters} must be supported, including the definition of the domain so that parameter changes can be validated. This is useful if others than the original game write have the privilege to change parameter values or to prevent careless mistakes.
\item The description mechanism must support the declaration of \textbf{output variables} as well as the definition of the output domain and the initial state of the variable. Output variables must be linked with a \textbf{state transition function} in order to specify how the output is calculated. This function must be able to access the set of parameters and the game history as described in equitation \ref{eq:transition2}. The outputs of previous rounds and of earlier declared output variables of this round should also be accessible in order to facilitate the implementation of the state transition functions. For the rest of the work, we will use the term game history in the broader sense including outputs. 
\item Furthermore it must be possible to define a \textbf{score function} and a \textbf{stop condition}. The latter can be defined e.g. in form of a parameter indicating the maximal number of rounds.
\end{itemize}

Apart from supporting round-based games the description mechanism should
\begin{itemize}
\item define an interface for virtual opponents which enables simulation or game sessions with real players against virtual opponents, 
\item provide a mechanism to define questionnaires between game rounds and/or at the beginning/end of the game,
\item provide means to define how round results, game history and results of the entire game are presented to the players.
\end{itemize}

\subsection{Game development environment}
\label{subsec:req:develop}

If the description mechanism from the last subsection is available the game writer needs a system or process which allows to
\begin{itemize}
\item write games and transmit the game description,
\item validate its syntax and semantics and receive feedback on possible mistakes,
\item save and register the game in the architecture if the syntax and semantics check has passed.
\end{itemize}

\subsection{Simulation environment}
\label{subsec:req:simulation}

After having registered a new game it must be made available for simulation. Here, in contrast to a real game session, the inputs for each round and for each player are provided by the simulation environment. Simulation allows the game developer to test the state transition functions and the correctness of the entire game by verifying if a given input results in the expected output. It can further be used to adjust game parameters. The simulation environment must provide means for debugging in order to locate and understand errors which might occur during game execution.

\subsection{Playing environment}
\label{subsec:req:play}

A game which has been successfully registered and proven to work correctly must be made available for online multiplayer game play. The playing environment must meet two main requirements:

\begin{description}
\item[Entrance hall.] This describes a mechanism to join players together who want to play the same game. Players must be informed about their waiting status if the minimal number of players for the game is not yet reached. The game is started after the minimal number of players is reached.

Eventually the automatic starting behaviour can be changed for a manual start triggered by the game creator. The game creator is the first person who joined the game. He might also be given the possibility to add virtual opponents to the game.
\item[Game engine.] Game engine describes a system which enables real time game play of multiple users. It must collect the user input and distribute it to an instance, which
\begin{itemize}
\item calculates the outputs by invoking the state transition functions,
\item distributes and shows the results to the players according to the game description,
\item handles timeout if a player does not provide his input decision within a predefined time frame,
\item saves all game states, parameters, etc. to the database for later analysis.
\end{itemize}
The game engine might also provide a mechanism to render questionnaires and display them to the players if included in the game description.
\end{description}

\subsection{Analysis environment}
\label{subsec:req:analysis}

The analysis environment must provide a mechanism to retrieve the collected data of all game sessions of a specific game from the database and deliver it to the user as csv-export. It might further include various possibilities to filter for specific parts of the game data before exporting it or it might provide an online view of the selected game data.

\section{Business Game Description (BGD)}
\label{sec:bgd}

As seen in requirement \ref{subsec:req:description}, a mechanism is needed with which game developers can write their own round-based business games. We call this feature Business Game Description (BGD) and there exist two major ways to approach it:

\begin{description}
\item[New programming language.] One possibility would be to invent a new programming language with its own syntax and keywords which meets all requirements from section \ref{subsec:req:description}. The set of keywords could be kept small compared to a conventional programming language and a language exclusively built in order to describe round-based games would be compact and easy to learn. After having defined this language it would be necessary to build either a compiler or a converter to another programming language. Writing a complete compiler for different architectures seems rather unfeasible given the existing resources. Writing a converter would be the second option, which is e.g. followed in the work of Tsuda et al. on BMDL \cite{tsuda2002compiler} as introduced in section \ref{sec:framework}. Yet, even a converter still needs a parser which complicates the processing of the language \cite{japanisch} and which is error-prone and time consuming to build. Moreover, libraries or existing projects which could facilitate the implementation of the system do not exist for a newly created language.
\item[General purpose language.] In the second approach the game itself is written in an object-oriented general purpose programming language. For game developers completely new to programming this might pose an obstacle although it should be quite easy to adopt existing examples in order to create a new game. The use of an existing programming language maintains a high flexibility since almost everything can be expressed and since a large variety of libraries and projects such as syntax highlighting, syntax checking, code reformatting etc. exists which can be used to facilitate the editing process. It is no longer necessary to write a resource-intensive parser which is the main reason for choosing this second approach in order to create the Business Game Description mechanism.
\end{description}

\subsection{BGD object model}
\label{subsec:bgd:model}

Figure \ref{fig:uml} shows the objects which are used in the Business Game Description mechanism. The Game object is the central element of BGD. It holds all methods that are needed to describe a round-based business game. At game development time, the game writer calls these methods in his game code in order to define and retrieve parameters, inputs, outputs and so on as explained in the following subsections. 

Doing so, the game writer does not need to instantiate the Game object in his code. He just calls the methods as if the Game object had been instantiated before. When some players want to play his game and start it, the game engine creates a new instance of Game. It then loads his code from the database and evokes it which will populate this very instance of Game with the parameters, inputs, outputs, state transition functions etc. which are needed to play his game.

\begin{figure}
	\centering
	\includegraphics[scale=0.565]{figures/gameUml.png}
	\caption{UML diagram of the Business Game Description (BGD) object model}
	\label{fig:uml}
\end{figure}

\subsubsection{Parameter object}
\label{subsub:parameters}

A parameter is a constant. The parameter object therefore holds two main attributes, which are the parameter name and the parameter value. The first is of type string, the latter can be string or numeric, depending on the game. In most cases, the parameter value will be numeric.

As stated in requirement \ref{subsec:req:description} it should be also possible to specify the parameter domain. This is done using a so called validation expression. A validation expression is an array of one or several expressions represented by strings. Every time the game code is saved to the database, e.g. after the it got created or after some changes took place, the parameter value will be matched against each of these expressions, resulting in an error if one of them fails. For example, if a game developer wants to express that the domain of his parameter $p1$ is defined as $p1 \in \{0,1\}$ the validation expression would be $\begin{pmatrix}
"\ge0"\\"\le1"\\"\%1==0"
\end{pmatrix}$. If one would try to set $p1 = 1.5$ the validation would fail at the third expression because $1.5\%1=0.5\neq0$. The concept of validation expressions will be also used to specify the domain of in- and output variables as shown in the next subsection.

At game development time, in order to define a new parameter, the game developer calls the \textit{game.addParameter()} method, specifying name, value and the validationExpression, the latter being an optional parameter. At game play, when his code gets evoked, this will implicitly result in the instantiation of a new parameter object by the game engine which will be added to the parameter collection of the game object. 

As shown in equitation \ref{eq:transition2} and \ref{eq:score} the state transition functions as well as the score function need access on the set of parameters. In the game code, this is done with the \textit{game.getParameter()} method. By specifying the name of the requested parameter this method returns the parameter value.

\subsubsection{Variable object}
\label{subsub:variables}

As seen in section \ref{sec:round}, in- and output variables play a fundamental role in round-based business games. In BGD, both are defined by passing a \textit{Variable} object to one of the \textit{game.add...Variable()} methods. The exact definition of these methods and the parameters they take will be explained in the following paragraphs. 

When the game is played, the game engine creates a new Game object and executes the game code. The Variable object, which was passed to the function, will be added to the Game object's array of input or output variables, depending on whether it was an instance of InputVariable or OutputVariable respectively. 

In order to retrieve the value of a variable for a given player and a given round, the game developer can use the \textit{game.get()} function. He will need this e.g. in the state transition functions in order to fetch values of in- and output variables from the game history.

If a state transition function $calcOut2$, which calculates output $out2$, retrieves $out1$ of this round, then $out1$ must be added before $out2$, since the output variables get calculated in the order in which they are added in the game code.

Moreover, each Variable object must specify the \textit{name} attribute and the name of the variables must be unique within one game, since it will be used e.g. in the \textit{game.get()} function as an identifier. The Variable object may further define the $initialValue$ and $calculationFunction$ attribute as we will see below.

\paragraph{Input variable.} An input can be defined calling the \textit{game.addInputVariable()} method. This method takes two parameters of which the first one is obligatory and of type \textit{InputVariable}. Thus, in order to create a new input the game writer first has to instantiate a InputVariable object in his game code. 

As seen in requirement \ref{subsec:req:description} two types of inputs exist, such of variable and such of predefined type. Both must specify the \textit{default} attribute. If a player leaves the game before it has ended or if he exceeds the maximal time to take a decision he will be expelled from the game and the default value will be his input for the remaining rounds. 

A variable input type is represented by the \textit{TextField} object. It must specify the \textit{type} attribute for input validation which can either take the value "number" or the value "string". It may additionally specify a validation expression in order to set out the exact subdomain of textual or numeric input.  

The predefined input type can either be of style \textit{checkbox} or \textit{scrolldown}. Both must define an array of values which represent the different options the player can choose between. Needless to say, the default value must be one of these options.

An input object may also define the \textit{calculateFunction} attribute which must be of type Function and which represents in the context of input variables the interface to virtual opponents. It is defined in the same manner as state transition functions from equitation \ref{eq:transition2}. Instead of calculating an output, this function defines how an input can be automatically generated. It is required if the game shall be available for simulation or if virtual opponents shall be added to games with real players. This is why it is strongly recommended to implement such a function. In most cases it will be enough to return e.g. a random number. At the same time this mechanism lays the foundation for sophisticated virtual agents since the game writer can access the complete game history and use any kind of programming he likes. The concept of calculatingFunctions will be explained more in detail in the next paragraph about output variables.

An input variable may further define an initial value. This is mathematically not needed, as seen in equitation \ref{eq:s0}, which shows that $S_0$ is fully described by the initial states of the output variables. Nevertheless it has proven practical for some game implementations.

As seen at the beginning of the paragraph, the \textit{game.addInputVariable()} method takes two parameters of which the second is optional. It is a Chart object and thus part of the presentation layer, using Google Charts\footnote{https://developers.google.com/chart/interactive/docs/gallery/piechart, retrieved on 20 Oct. 2015} for visualization. If it is specified the players will see a chart in each round which shows the values of this input variable of every player of the previous rounds. The Chart object describes how this chart should look like. So far, the types \textit{Pie Chart}, \textit{Column Chart} and \textit{Area Chart} are supported. XXX DESCRIBE CHART OBJECT MORE IN DETAIL XXX

\paragraph{Output variable.} With \textit{game.addPlayerVariable()} and \textit{game.addRoundVariable()} two \newline  
methods exist in order to introduce a new output variable in the game code. This seems strange since the framework for round-based BGs from section \ref{sec:round} knows only only one type of output. The difference between both can be explained assuming a business game which implements an output variable \textit{market demand} which changes in each period and which is calculated as a random number. In one period, the market demand is supposed to be the same for each player. Mathematically, it is not necessary to differentiate such an output from one that is different for every player. In the output matrix from equitation \ref{eq:output} this market demand variable would just result in one row with identical numbers for every player. However, programmatically it makes sense to distinguish between a \textit{Player(output)Variable} and a \textit{Round(output)Variable} since the latter needs to be calculated and stored only once per round while the first needs to be calculated and stored per round and per player. 

Same as the value of an input variable, the value of an output variable can be retrieved from the game history with the \textit{game.get()} function. In case of a round-specific OutputVariable the \textit{playerID} parameter is optional and gets ignored if specified. In case of a player-specific OutputVariable it is obligatory resulting in an error if not specified. The \textit{game.get()} function takes also the \textit{roundIndex} as a mandatory parameter, specifying the round index for which the output value should be fetched. Supposing a BGD implementation where the first round has $roundIndex = 0$ for the rest of this chapter, any access on a negative roundIndex will return the initial state of the variable which is part of the initial game state $S_0$.

Both output-adding methods introduced at the beginning of this paragraph take two parameters; the first being obligatory and of type OutputVariable, the second being an optional Chart object. As with the inputs, the Chart object is used to visualize outputs. All in all, the OutputVariable object resembles InputVariable. It must define the name and the calculationFunction attribute and it should define an initial value and a validation expression.

The calculationFunction attribute links the OutputVariable object with a function. This function presents the algorithm which defines how the output is calculated. It is thus the programmatic counterpart to a state transition function as introduced in equitation \ref{eq:transition2}. If the function is linked with a player-specific OutputVariable (or an InputVariable as described in the last paragraph) it must be defined with \textit{playerID} as parameter. If it is linked with a round-specific OutputVariable it must be defined without parameters. It must always return a value which is within the domain of the output (input) variable which it is supposed to calculate. When the game is played, the game engine calls this function every round in order to calculate the output (input) value. For a player-specific OutputVariable or an InputVariable it will be called for each player with the playerID of the current player passed as parameter. For a round-specific OutputVariable it will be called once per round without parameters. 

Defining an attribute which is of type \textit{Function} may seem strange. This is why it should be noted here that the programming language used to implement BGD should support first-class functions and closures. The first means that a function is nothing else than an object which can be e.g. stored in a variable or passed as parameter to another function. Like this the calculationFunction attribute of a Variable object can be of type Function. A closure means that a function has access to the variables from the context from which it was called. We refer to the Implementation chapter for further details.

As mentioned before, an OutputVariable object \textit{should} have the iniatialValue and validationExpression attribute which means it is strongly recommended to include them in every game implementation. A missing initialValue means that the game state $S_0$ is not fully described. Any access on the missing part will result in error. The validationExpression in output variables is extremely useful in order to validate the correctness of the implementation of the state transition functions. If an error in some function or in the interaction between several functions produces an output value which is not within the correct domain, the error from a failing validation expression can accelerate and facilitate the debugging process.

\subsubsection{Score function}
\label{subsub:score}

The game developer can register a score function by passing it as parameter to the \newline \textit{game.addScore()} method. The score function should look like a calculationFunction of a PlayerVariable as described in the last subsection and follow the definition from equitation \ref{eq:score}. Consequently it is a function which takes the playerID as parameter and which returns a score value $\in \mathbb{R}$. Every game should implement a score function since otherwise it won't have a winner and the players won't get evaluated individually.

Internally, the concept of the score function uses the same mechanism as variables. The \newline \textit{game.addScore()} call will result in the automatic creation of two OutputVariable objects, one being player-specific and one being round-specific. Both are added at the end of the Game object's array of output variables. Since they are added at the end, when playing the game, all other outputs will be calculated before and can be accessed for all so far played rounds including the current one in the calculationFunctions of the two new objects.

The first of these new OutputVariables is called \textit{roundScore} and its calculationFunction is the player-specific score function specified by the game developer. The second is called \textit{accumulatedScore}. Its calculationFunction is automatically generated and defined as introduced in equitation \ref{eq:accumulated}. If an optional Chart object was passed as second parameter to the \textit{game.addScore()} method, it will be used to visualize the accumulatedScore variable which shows in each round the so far reached total score of each player.

The \textit{game.addCollectiveScore()} method is the second score-related functionality of the Game object. Game developers can use it to register a collective score function which evaluates the performance of the players altogether in one period as defined in equitation \ref{eq:collectivescore}. E.g. in the \textit{beergame}, which was first described by John Sterman \cite{beergame}, the players are asked to minimize the collective costs over the whole organization (collective score) while only having local information about their own costs (individual score). The concept of collective score can be used to model such a behaviour. Internally it works the same as the individual score, adding two OutputVariables \textit{collectiveRoundScore} and \textit{accumulatedCollectiveScore}.

\subsubsection{Questionnaire object}
\label{subsub:quest}

Questionnaires as formulated in requirement \ref{subsec:req:description} can be included to a game by calling the \textit{game.addQuestionnaire()} method in the game code. It takes as first parameter the name of the questionnaire, as second parameter a Questionnaire object and as last parameter a position array.

A Questionnaire object has a name and a position which are implicitely set by the addQuestionnaire() method. It further holds an array of Questions, of which each defines a question name, a question text and an answer. The answer attribute can be either of type string or of type array of strings. If it is of type string it can take the values "string" or "number", indicating a question with variable input which may be textual or numeric. An answer of type array of strings represents a question with predefined answers; each element in the array becomes one of the options the player can choose between in order to answer the question.

The last parameter, the position array, must be an array of numbers $\in \mathbb{Z}$ defining the position(s) the questionnaire will be shown at. This means that the same questionnaire can occur once or several times at different positions of the game. Each entry in the array stands for a round after which the questionnaire will turn up. A large number bigger than the maximal number of rounds of the game means that the questionnaire will appear at the end while -1 indicates that it will appear before the first round of the game.

\subsubsection{Mathematics and Utility object}
\label{subsub:util}

Both objects provide access to functions which are supposed to facilitate the game development. So far, one util and four math functions are specified. Future game implementations may bring up the need for further functionality.

With \textit{game.util.getWeekNumber()} the game developer can get the calendar week of a date by passing the corresponding date object to this function. This is useful for game implementations where one period consists of one calender week and their numbering e.g. in a chart should start with the current week.

There are two math functions \textit{random()} and \textit{randomInt()} which are intended to help with random numbers since those are often needed for very simple implementations of virtual agents. Both take a numeric minimum $min$ and maximum $max$ value as parameter and return a random value $rv$ with $rv \in [min, max]$. It is further $rv \in \mathbb{R}$ for the first function and $rv \in \mathbb{Z}$ for the second function respectively.

The math functions \textit{proportionalDistribution()} and \textit{inverseDistribution()} are inspired from BMDL \cite{tsuda2002compiler} and practical for many game implementations. Assuming a game where two players have to decide upon a price $p_1$ and $p_2$ in each period for a product they want to sell. If the market volume is 100 tons ($distrVal$) and $p_1=75$\euro \space ($distrByVal_1$) and $p_2=25$\euro \space ($distrByVal_2$) a proportional distribution of this market would mean that player one can sell 75 tons à 75\euro \space and player two can sell 25 tons à 25\euro. However, the more realistic distribution in this example would be a (proportional) inverse distribution, where player one with the high price can only sell 25 tons and player two with the low price can sell 75 tons.

For player $i$ with $i\in\{1,\dots, n\}$ the proportional distribution is
\begin{align}
    propDistr_i=\frac{distrVal}{\sum_{i=1}^n distrByVal_i}*distrByVal_i,
\end{align}
while the inverse distribution is defined as
\begin{align}
    invDistr_i=\frac{distrVal}{\sum_{i=1}^n propDistr_i^{-1}}*propDistr_i^{-1}.
\end{align}

This reflects the three obligatory parameters of both distribution functions. The first parameter is the \textit{playerID}. The second parameter is called \textit{distributionValue}. It may either be a number or the name of a round-specific output variable. In the example above the distributionValue was 100 (tons). Supposed that the market volume is stored in the round-specific output variable with the name of $marketVol$, we can just pass this name as second parameter to one of the distribution functions. The game engine will then retrieve the value of $marketVol$ for the current round to calculate and set it as distributionValue. Passing the name of a player-specific output variable or of an input variable (which is also player-specific) will result in an error.

The third parameter is called \textit{distributeByVariableName}. This must be the name of a player-specific output variable or the name of an input variable by which the distributionValue should be proportionally or inversely distributed, as e.g. $price$ in the example above. 

The fourth parameter \textit{optionalRoundIndex} is optional. It is an array of (two) numeric entries $\in \mathbb{Z}$. OptionalRoundIndex[0] $\le t,t\in\{1,\dots, T\}$ specifies the round index for the distributionValue, if it refers a variable. Using the example above it could be e.g. expressed to always use the market volume of the previous round instead of the current round as distribution value by setting optionalRoundIndex[0] = currentroundIndex-1. OptionalRoundIndex[1] $\le t$
is used as round index for the distributeByVariable. If one or both values are not specified or if the whole parameter is missing, the current round will be used for calculation.

Last but not least the two functions \textit{game.getCurrentRound()} and \textit{game.getNumberOf-\newline Players()} should be mentioned for their importance, even though they do not belong to the Mathematics or Utility but directly to the Game object. The first returns the index of the current round the game is in at the moment. Please recall that the first round has $roundIndex=0$. This feature is needed in virtually every state transition function in order to retrieve an in/output of the current round, the previous round, and so on. The second function returns the number of players $playerCount$ that are actually playing the game (at runtime). This is also an important functionality in many implementations since the developer at development time does not know yet how many players are going to play but only provides the minimal and maximal number of players. It can be used to retrieve something from the game history for \textit{all} players, using a loop from 0 to $playerCount-1$ and assuming a BGD implementation where $playerIDs =\{ 0,1\dots, n-1\}$. It is needed e.g. in the collectiveScore function of the beergame where the costs over all players need to be added together. 

\subsection{BGD development}
\label{subsec:bgd:develop}

Requirement \ref{subsec:req:develop} specifies a development mechanism which should allow developers to write, verify and transmit their game code and to register it in the architecture. Two major approaches to realize this behaviour can be distinguished:

\begin{description}
\item[Manual verification.] The game developer writes his BGD-code in a text editor of his choice and transmits it via email or via a http-upload mechanism to a central control instance. This instance performs a manual or semi-automatic check for malicious code and for mistakes. Syntax errors or minor semantic errors can be corrected by the control instance. If the code then works correctly it can be registered in the architecture. If it contains more severe errors the game developer is provided with feedback and asked to review his code.

Since BGD uses a general purpose programming language for game implementation security concerns must be taken into account because executing untrusted game code could harm the architecture. A manual code check would minimize this risk, at least if carried out with proper care. It is on the other hand a very inflexible, time consuming and expensive solution since it needs an experienced reviewer who is constantly available for game verification. It is unattractive for the game developer as well who wants to have immediate feedback on his implementation and not wait for the reviewing-process.

\item[Automatic verification.] Automatic verification means the installation of a system which automatises all steps previously undertaken by a manual reviewer. This implies that the game developer can upload his code as a file or write it within the system and have it then automatically checked for syntax and semantic errors as well as for malicious code. If the code is free of such errors and can be trusted it is saved and registered in the architecture, otherwise the developer is provided with feedback. We prefer this approach since it makes the entire architecture more attractive and thus more likely to be used for active game development of round-based business games.
\end{description}

\subsubsection{Security considerations}
\label{subsub:security}

Supposing a client-server architecture the central security-related question is whether the potentially harmful game code gets executed on the server or on the client.

\paragraph{Server-side.} If untrusted code is planned to be executed on the server strong security measures must be taken. The following list shows advantages and disadvantages of such possible measures which can be also used in combination:
\begin{itemize}
\item The code can be searched with the help of regular expressions in order to forbid access on global variables or on critical functionality as e.g. access on the file-system and so on. This approach is very weak and provides only little security since regular expressions are error-prone, need a lot of testing and it is very hard to cover every loophole the attacker might take.
\item When the code or parts of it get executed, a new worker process can be started executing the piece of code in question. A new process is automatically separated from the process(es) of the architecture and the server, which means it cannot access the same space of memory. If possible, this process should be started with limited privileges. The ability to do so depends on the technology that is used on the server as well as the platform it runs on. 

In general, this measure supposes that the complete inter-process-communication between the architecture and the worker process must be established over the pipe. This implies that all communication objects must be serializable, complicating the implementation of such a system. Depending on the technology used, functionality might exist which facilitates inter-process-communication. 

It furthermore results in the creation of many processes since each execution of e.g. a state transition function means running untrusted code which has to be secured in a new process. Depending on the number of games that currently run on the server and the number of variables and players of each game this measure produces a lot of overhead and can have a significant impact on the server's performance.
\item In order to reduce this overhead one could try to start only one worker process responsible for every execution of untrusted code. In addition to the necessity of inter-process-communication this approach is very hard to synchronize.
\end{itemize}

\paragraph{Client-side.} In the case of BGD, speaking of a client means the browser of the player(s) since all games are supposed to be browser-based. Consequently, security concerns must not be considered when running untrusted code on the client-side since this is done everyday on the internet and taken care off by the browser's sandbox. 

\subsubsection{Game verification}
\label{subsub:verification}

The automatic verification system of the BGD development environment must provide feedback on possible errors. It can be differentiated whether the error is related to the syntax or the semantics of the game code.

\paragraph{Syntax.} The syntax of BGD is defined by the programming language that is used for its implementation. A typical syntax error would be e.g. a missing bracket. Open source parser exist for all major programming languages providing feedback if the parsing was successful or if and where problems were detected. All further checks beyond the syntax of the code should only take place after the syntax check has succeeded.

\paragraph{Semantics.} A semantically correct game implementation provides all the mechanisms and objects that fully describe a round-based business game as seen in section \ref{subsec:framework} and \ref{subsec:bgd:model}. A semantic test can e.g. check if all necessary state transition functions are specified but it cannot prove the correctness of their implementation. This can be done only at runtime, e.g. in a simulation.

With \textit{error}, \textit{warning} and \textit{success} three different alert levels can be distinguished. An error signifies a missing or incorrect implementation of a feature that would always result in failure at runtime. If a semantic error is detected feedback must be provided and the code must not be further tested or registered in the architecture. It should be especially checked, if

\begin{itemize}
\item all default parameters ($maxrounds$, $minplayers$, $maxplayers$, $timeout$) are specified,
\item all parameter values match against their validation expressions, if provided,
\item each variable has a name and this name is unique among all variables,
\item at least one input variable is defined,
\item each input variable defines a semantically correct InputType object, which means that all obligatory attributes are set and the default value matches the domain,
\item each output variable specifies a calculation function.
\end{itemize}

Warning or success means that the game can be further tested or registered in the architecture. A warning signifies a missing feature that might result in failure at runtime. It should provide feedback and especially test, if
\begin{itemize}
\item each input variable provides a calculation function since this is e.g. needed for simulation,
\item each output variable provides an initial value since otherwise the game might fail at runtime if the initial game state is accessed, 
\item each output variable defines a validation expression in order to detect errors in state transition functions and facilitate their debugging, 
\item the game provides a score function.
\end{itemize}

\section{Business Game Engine (BGE)}
\label{sec:bge}

The term \textit{Business Game Engine} (BGE) is used for the architecture as a whole. Business Game Description (BGD) as well as all required environments from section \ref{sec:requirements} are thus part of BGE. 

From the topmost point of view BGE is as a client-server architecture with a database. One of its modules is the \textit{startpage}, which is comparable to the index.html file or the home page of a website. It contains a list with the names of all available business games on this instance of BGE and provides access to all environments, which are the development, simulation, playing and analysis environment.

\subsection{Development environment}
\label{subsec:bge:d&a}

For game development BGE implements the automatic verification development mechanism from section \ref{subsec:bgd:develop}. It consists of the modules \textit{Online editor} and \textit{Feedback screen} and accesses the database. A full implementation provides at least the functionality \textit{create}, \textit{edit} and \textit{delete}.

\begin{description}
\item[Create.] Linked from the startpage the editor module is loaded. The game developer can type his BGD code here. The feedback screen module informs of possible syntax and semantic errors and might inform if parts of the code are considered to be malicious. If all tests have passed the game code can be allowed to be written to the database, together with an unique game name, a password and eventually additional information about the developer, game content and so on. The password is used to grant access to the privileged operations edit and delete.
\item[Edit.] Linked from the start page in combination with the choice of a specific game from the game list the game code of this game is loaded into the editor module if the user is privileged to do so. He can then edit and save the game code under the same conditions as described in the create functionality. E.g. parameter changes are performed in this way. \newline XXXXXX\newline
Code history: Entweder einfach update (woher weiß man wann welche Version vorlag? Game code zusammen mit Spiel session abspeichern?) oder edit verbieten, nachdem schon gespielt wurde, oder code-history (!!Tricky!! konkurrierende Zugriffe) \newline
XXXXXX
\item[Delete.] This functionality deletes a game from the database if the correct password is provided.
\end{description}

The development environment might also implement a \textit{show code} functionality which shows the code in read-only mode without asking for a password.

\subsection{Simulation and playing environment}
\label{subsec:bge:simplay}

As the edit or delete functionality from above, the simulation and playing environment is linked from the startpage after the user has chosen one specific game he wants to simulate or play.

The Game object introduced in the UML diagram in figure \ref{fig:uml} holds an array of Round and Player objects that were not spoken about so far. This is the case because they cannot be addressed by the game developer at development time but get important at runtime, when simulating or playing the game.

\subsubsection{Player}
\label{subsub:player}

The Player object describes a player using a name, nickname and email address. This selection is only a proposition. In an BGE implementation where only registered users are allowed to play it might be enough to use the playerID since all other information is already available in the database. In an open BGE implementation other player-describing attributes might be added. 

When a player $p1$ wants to play a game called $easyBG$, BGE creates a Player object $p1\_obj$ that describes him and checks among all currently existing Game objects for a game with the name of $easyBG$ that has the \textit{isOpen} attribute set to $true$. If such an object is found, the player joins it, which means $p1\_obj$ is added to the Game object's array of players. If such an object is not found, either because all games of this type have already been started ($isOpen=false$) or because no such games exist at the moment, a new Game object is instantiated. Its name is $easyBG\_obj$, it is open, $p1\_obj$ is the first object in its array of players and it is now waiting for other players to join.

This functionality described above is part of the \textit{entrance hall} module of BGE. Depending on its implementation the game is started after the minimum number of players is reached or after the game creator (the first player who joined the game) starts the game. Additional virtual opponents might be added to the game, resulting in the \textit{isBot} attribute of their Player objects to be set to \textit{true}. 

In its easiest implementation, as  already mentioned at the end of section \ref{subsub:util}, the playerIDs correspond with the indices of the Game object's player array. This means that $playerIDs = \{0,\dots, n-1\}$. If we suppose that $p1\_obj.playerID = 1$ this means that $p1$ was the second player who joined the game and that $game.players[1]$ contains $p1\_obj$.

If a game is simulated but not really played, a random number $rand$ of virtual agent Player objects is created, with $rand \in [minplayers, maxplayers] \in \mathbb{N}$ and the game is started immediately. 

\subsubsection{Round}
\label{subsub:round}

Round objects get important after the game has been started. They are used to fully describe the round of a game. When a new round is started, a new Round object is created and added to the Game object's array of rounds. During and at the end of the round, in- and output values are written to this Round object. The BGE module responsible for handling games that have been started is called \textit{game engine}.

The form of a Round object, which means the majority of its attributes as well as their domain, is dependent on the game that is played. Let us assume \textit{easyBG} from the example above has the input \textit{price} and two outputs \textit{marketVolume} and \textit{profit}, the first being round-specific and the latter being player-specific. The domain of all three variables is supposed to be numeric. This will result in Round objects with the three game-dependent attributes \textit{price, marketVolume} and \textit{profit} of which the first and the last are of type array of numbers and the second is of type number. If \textit{easyBG} specifies a score function, two more attributes with the name  \textit{roundScore} and \textit{accumulatedScore} of type array of numbers will be added to its Round objects. 

Assuming player $p1$ from the example above is playing \textit{easyBG}, the entrance hall module is implemented so that $playerIDs = \{0,\dots, n-1\}$ and the game is in the third round. $P1$ decides to set up a price of 50\euro \space per ton and the market volume of this period as well as his profit is calculated as 300 tons and 8000\euro. This results in $game.rounds[2].price[1]=50$, $game.rounds[2].marketVolume=300$ and $game.rounds[2].profit[1]=8000$. Please recall that $roundIndex = roundNumber - 1$ which means that the third round has the index two and that \textit{game.getCurrentRound()} returns the $roundIndex$, not the $roundNumber$. The command to retrieve \textit{p1's} profit of the previous round in the game code would be $game.get("profit", game.getCurrentRound()-1, 1)$.

In other words, each player-specific in- or output variable is translated into an attribute with the name of the variable and of type array of string or array of number. The length of this array is the number of players that are currently playing the game. The realisation of the in- or output variable for player $i$, after the input has been decided or the output has been calculated, is stored in this array at index $i$, with $i \in playerIDs = \{0,\dots, n-1\}$. A round-specific output variable is translated in an attribute of type string or number which is used to store the realisation of this output variable.

If a BGE implementation uses $playerIDs \neq \{0,\dots, n-1\}$, an additional mapping function $mf$ with
\begin{align}
mf \colon playerIDs \to \{0,\dots, n-1\}
\end{align}
is needed, in order to retrieve a player-specific variable value or to access the corresponding Player object.

\subsubsection{Game\&simulation flow}
\label{subsub:flow}

XXXXXXXXXXXXXXXXXXXXXXXXXXX

This section tries to summarize all the necessary steps that must be taken by the entrance hall and game engine module in order to enable game play or simulation using the example...

\paragraph{Entrance hall.} 
\begin{enumerate}
\item First player $p0$ joins the game. Create $p0\_obj$ and set $name=p0$, $isBot=false$ and $abort=false$. The abort attribute is set true if a player leaves a game before finishing it or if he does not decide within the maximal decision time. Additional information such as nickname, email etc. can be asked for as well.
\item Instantiate new Game object $easyBG\_obj$. Set $ID$ to an unique value, \newline $name=easyBG$, $isOpen=true$ and $currentRound=0$. Add $p0\_obj$ to the $easyBG\_obj.players$ array.
\item Wait for other players and add their objects when they join.
\item The game can be started when $playerCount \in  [minplayers, maxplayers].$ If this is only a simulation, create a valid number of virtual agents and start the game.
\end{enumerate}

\paragraph{Game engine.} 
\begin{enumerate}
\item 
\end{enumerate}
XXXXXXXXXXXXXXXXXXXXXXXXXXX
\subsection{Analysis environment}
\label{subsec:bge:analysis}
XXXXXXXXXXXXXXXXXXXXXXXXXXX


